<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eco FoodCalc - Diet Optimizer</title>
    <style>
        /* Basic Styles */
        body { font-family: sans-serif; margin: 20px; }
        h1 { color: #333; }
        .food-list { width: 100%; border-collapse: collapse; margin-top: 20px; }
        .food-list th, .food-list td { border: 1px solid #ccc; padding: 8px; text-align: left; }
        .food-list th { background-color: #f2f2f2; }
        
        /* Status and Tag Styles */
        .status-select { padding: 5px; border-radius: 4px; }
        .tag-button { 
            margin: 2px; 
            padding: 5px 10px; 
            cursor: pointer; 
            border: 1px solid #aaa; 
            border-radius: 4px;
            background-color: #e9e9e9;
        }
        .tag-favorite { background-color: #ffd700; border-color: gold; font-weight: bold; }
        .tag-worst { background-color: #ffb6c1; border-color: #f08080; }

        /* Footer Style */
        footer { margin-top: 50px; font-size: 0.8em; color: #666; }
        
        #food-search-input {
            padding: 10px;
            font-size: 16px;
            width: 50%;
            margin-top: 10px;
        }
        #stomach-size-input {
            padding: 5px;
            width: 80px;
            text-align: right;
        }
    </style>
</head>
<body>

    <h1>Eco FoodCalc - Diet Optimizer</h1>
    
    <p>Current Session Status: <span id="user-session"></span></p> 
    <p>This tool helps maximize your **Nutrition Bonus** for faster skill point gain in Eco.</p>
    
    <div style="margin-bottom: 20px;">
        <label for="stomach-size-input">Stomach Size (Calories): </label>
        <input type="number" id="stomach-size-input" value="3000" min="100" onchange="updateStomachSize(this.value)">
    </div>
    
    <div id="food-container"></div> 

    <footer>
        <hr>
        <p>Created by CrazySpy - Version 0.1 - Last update: <span id="last-update-date"></span></p>
    </footer>

    <script>
        const FOOD_SOURCE_URL = 'foodsource.json';
        
        // Define ALL possible status states. Renamed 'NEVER_TRIED' to 'REMOVE_FROM_LIST'.
        const FOOD_STATUS_KEYS = {
            'REMOVE_FROM_LIST': 'Remove from list', 
            'DELICIOUS': 'Delicious', 
            'GOOD': 'Good', 
            'OK': 'Ok', 
            'BAD': 'Bad', 
            'HORRIBLE': 'Horrible'
        };

        const STATUS_OPTIONS = Object.values(FOOD_STATUS_KEYS);
        const DATA_STORAGE_KEY = 'eco_food_preferences';
        const STOMACH_SIZE_KEY = 'eco_stomach_size';
        
        // Global variables
        let foodData = [];
        let userPreferences = {};
        let stomachSize = 3000;

        // --- Core Functions ---

        /**
         * Initializes the application: loads JSON data and user preferences.
         */
        async function initApp() {
            const container = document.getElementById('food-container');
            const sessionElement = document.getElementById('user-session');
            
            sessionElement.textContent = 'Checking preferences...';
            container.innerHTML = 'Loading food data...';

            try {
                // 1. Load the JSON file
                const response = await fetch(FOOD_SOURCE_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                foodData = await response.json();

                // 2. Load user preferences and stomach size
                loadUserPreferences();
                loadStomachSize();

                // 3. Render the two main components (Evaluated List + Search)
                renderFoodLists(); 
                
            } catch (error) {
                console.error("Error loading or processing JSON:", error);
                container.innerHTML = `<p style="color: red;">Error loading ${FOOD_SOURCE_URL}. Please check the file name and format.</p>`;
                sessionElement.textContent = 'Failed to start session.';
            }

            // 4. Fetch the last commit date (footer)
            fetchLastCommitDate();
        }

        /**
         * Loads preferences from localStorage or sets initial 'Remove from list' status.
         */
        function loadUserPreferences() {
            const storedData = localStorage.getItem(DATA_STORAGE_KEY);
            const sessionElement = document.getElementById('user-session');

            if (storedData) {
                userPreferences = JSON.parse(storedData);
                sessionElement.textContent = 'Preferences loaded.';
            } else {
                // Initialize preferences: every item starts as 'Remove from list'
                foodData.forEach(item => {
                    const name = item.Food_Name;
                    userPreferences[name] = {
                        status: FOOD_STATUS_KEYS.REMOVE_FROM_LIST, 
                        isFavorite: false,
                        isWorst: false
                    };
                });
                saveUserPreferences();
                sessionElement.textContent = 'New session initialized (All set to Remove from list).';
            }
        }
        
        /**
         * Loads the Stomach Size from localStorage or defaults to 3000.
         */
        function loadStomachSize() {
            const storedSize = localStorage.getItem(STOMACH_SIZE_KEY);
            if (storedSize) {
                stomachSize = parseInt(storedSize);
            }
            // Update the input field with the loaded/default value
            document.getElementById('stomach-size-input').value = stomachSize;
        }

        /**
         * Saves current user preferences to localStorage.
         */
        function saveUserPreferences() {
            localStorage.setItem(DATA_STORAGE_KEY, JSON.stringify(userPreferences));
        }
        
        /**
         * Saves the Stomach Size to localStorage.
         */
        function saveStomachSize() {
            localStorage.setItem(STOMACH_SIZE_KEY, stomachSize);
        }
        
        /**
         * Updates the stomach size variable and saves it.
         */
        function updateStomachSize(newValue) {
            stomachSize = parseInt(newValue) || 3000;
            saveStomachSize();
            console.log(`Stomach size updated to ${stomachSize} kcal.`);
            // You might want to re-render the optimization results here later
        }


        /**
         * Renders the two main lists: Evaluated Foods Table and Search Box.
         */
        function renderFoodLists() {
            const container = document.getElementById('food-container');

            // Separa as comidas em avaliadas e não avaliadas (status != REMOVE_FROM_LIST)
            const allFoods = [...foodData];
            const evaluatedFoods = allFoods.filter(item => {
                const prefs = userPreferences[item.Food_Name];
                return prefs && prefs.status !== FOOD_STATUS_KEYS.REMOVE_FROM_LIST;
            });
            const unevaluatedFoods = allFoods.filter(item => {
                const prefs = userPreferences[item.Food_Name];
                return !prefs || prefs.status === FOOD_STATUS_KEYS.REMOVE_FROM_LIST;
            });
            
            // Renderiza o Container Principal
            let html = '<h2>1. Your Evaluated Foods</h2>';
            html += '<p>Manage the foods you have already tried and set their taste status and tags. (Evaluated Foods: ' + evaluatedFoods.length + ')</p>';
            html += renderEvaluatedTable(evaluatedFoods);

            html += '<hr style="margin: 40px 0;">';
            
            html += '<h2>2. Evaluate New Foods</h2>';
            html += '<p>Search or select a food to add it to your evaluated list and set its status.</p>';
            html += renderSearchInterface(unevaluatedFoods);

            container.innerHTML = html;
        }

        /**
         * Renders the table for foods that have an explicit status set.
         */
        function renderEvaluatedTable(foods) {
            if (foods.length === 0) {
                return '<p>No foods evaluated yet. Use the search field below to add your first item!</p>';
            }

            let tableHtml = '<table class="food-list">';
            tableHtml += '<thead><tr><th>Food Name</th><th>Carbs</th><th>Fat</th><th>Protein</th><th>Vitamins</th><th>Calories (Game)</th><th>Status</th><th>Tags</th></tr></thead>';
            tableHtml += '<tbody>';

            foods.forEach(item => {
                const name = item.Food_Name;
                const prefs = userPreferences[name];
                
                const favClass = prefs.isFavorite ? ' tag-favorite' : '';
                const worstClass = prefs.isWorst ? ' tag-worst' : '';
                
                tableHtml += `<tr>
                    <td>${name}</td>
                    <td>${item.Carbs}</td>
                    <td>${item.Fat}</td>
                    <td>${item.Protein}</td>
                    <td>${item.Vitamins}</td>
                    <td>${item.Official_Calories_Game}</td>
                    <td>
                        <select class="status-select" onchange="updateFoodStatus('${name}', this.value)">
                            ${STATUS_OPTIONS.map(s => 
                                `<option value="${s}" ${s === prefs.status ? 'selected' : ''}>${s}</option>`
                            ).join('')}
                        </select>
                    </td>
                    <td>
                        <button class="tag-button${favClass}" onclick="toggleTag('${name}', 'isFavorite')">${prefs.isFavorite ? '★' : '☆'} Favorite</button>
                        <button class="tag-button${worstClass}" onclick="toggleTag('${name}', 'isWorst')">${prefs.isWorst ? '☠' : '⛌'} Worst</button>
                    </td>
                </tr>`;
            });

            tableHtml += '</tbody></table>';
            return tableHtml;
        }

        /**
         * Renders the search/selection interface (using datalist for type-ahead search).
         */
        function renderSearchInterface(foods) {
            // Cria a lista de opções para o datalist
            const options = foods.map(item => `<option value="${item.Food_Name}">`).join('');
            
            let searchHtml = `
                <input list="food-datalist" id="food-search-input" onchange="addFoodToEvaluatedList(this.value)" placeholder="Type or select food name (${foods.length} remaining)" autocomplete="off">
                <datalist id="food-datalist">
                    ${options}
                </datalist>
                <p style="margin-top: 10px; font-size: 0.9em; color: #666;">Note: After typing a name, click outside the box or press Enter to add the food.</p>
            `;
            return searchHtml;
        }
        
        /**
         * Adds a selected food from the search box to the evaluated list by updating its status.
         */
        function addFoodToEvaluatedList(foodName) {
            // Encontra o item (case sensitive) e garante que ele existe e ainda não foi avaliado
            const itemKey = foodData.find(item => item.Food_Name === foodName)?.Food_Name;
            
            if (!itemKey) {
                alert(`Food "${foodName}" not found or already evaluated.`);
                document.getElementById('food-search-input').value = ""; // Clear input
                return;
            }

            // Define o novo status como 'Delicious'
            const defaultNewStatus = FOOD_STATUS_KEYS.DELICIOUS;

            // Atualiza a preferência do usuário (tira do Remove from list)
            userPreferences[itemKey].status = defaultNewStatus;
            
            // Salva e re-renderiza as duas listas
            saveUserPreferences();
            renderFoodLists();
            
            document.getElementById('food-search-input').value = ""; // Limpa a caixa de busca
        }


        // --- User Interaction Functions ---

        /**
         * Updates the status (Delicious, Good, etc.) for a food item and re-renders if needed.
         */
        function updateFoodStatus(foodName, newStatus) {
            userPreferences[foodName].status = newStatus;
            
            // Se o status for alterado para ou de 'Remove from list', precisamos re-renderizar para mover o item.
            const shouldRerender = newStatus === FOOD_STATUS_KEYS.REMOVE_FROM_LIST || 
                                   (userPreferences[foodName].status !== newStatus); // Se o status antigo era REMOVE

            saveUserPreferences();
            
            if (shouldRerender) {
                 renderFoodLists(); 
            }
            console.log(`Status of ${foodName} updated to ${newStatus}.`);
        }

        /**
         * Toggles the Favorite or Worst tag for a food item and re-renders.
         */
        function toggleTag(foodName, tag) {
            userPreferences[foodName][tag] = !userPreferences[foodName][tag];
            saveUserPreferences();
            renderFoodLists(); // Re-render to update tag button appearance and lists
            console.log(`${tag} status for ${foodName} toggled.`);
        }
        
        // --- Footer Functions ---
        
        /**
         * Fetches the date of the last commit from the GitHub API.
         */
        async function fetchLastCommitDate() {
            const dateElement = document.getElementById('last-update-date');
            dateElement.textContent = 'fetching commit data...'; // Dynamic loading

            const repoOwner = 'Crazy-Spy';
            const repoName = 'EcoFoodCalc';
            const branchName = 'main'; 
            const apiURL = `https://api.github.com/repos/${repoOwner}/${repoName}/commits/${branchName}`;

            try {
                // Check local storage for cached data (using ETag for efficiency)
                const cachedDate = localStorage.getItem('last-commit-date');
                const etag = localStorage.getItem('last-commit-etag') || '';

                const response = await fetch(apiURL, {
                    headers: {
                        'If-None-Match': etag
                    }
                });

                if (response.status === 304) {
                    // Not Modified: use cached date
                    if (cachedDate) {
                        dateElement.textContent = cachedDate;
                        return;
                    }
                }
                
                if (!response.ok) {
                    throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                const lastCommitDate = new Date(data.commit.author.date);
                
                // Format: DD/MM/YYYY HH:MM (24h format)
                const formattedDate = lastCommitDate.toLocaleDateString('pt-BR', {
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: false
                });

                dateElement.textContent = formattedDate;

                // Save new data to localStorage
                localStorage.setItem('last-commit-date', formattedDate);
                localStorage.setItem('last-commit-etag', response.headers.get('ETag'));

            } catch (error) {
                console.error("Failed to fetch GitHub commit date:", error);
                dateElement.textContent = 'Error fetching date.';
            }
        }


        // Initialize the application
        initApp();
    </script>
</body>
</html>
