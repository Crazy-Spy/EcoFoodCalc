<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eco FoodCalc - Diet Optimizer</title>
    <style>
        /* Basic Styles */
        body { font-family: sans-serif; margin: 20px; }
        h1 { color: #333; display: inline-block; margin: 0; }
        
        /* Version Top Right */
        #version-display { float: right; font-size: 0.9em; color: #555; }
        
        .food-list { width: 100%; border-collapse: collapse; margin-top: 20px; }
        .food-list th, .food-list td { border: 1px solid #ccc; padding: 8px; text-align: left; }
        .food-list th { background-color: #f2f2f2; }
        
        /* Highlighting Rows */
        .row-favorite { background-color: #fffacd; /* Light Yellow */ }
        .row-worst { background-color: #ffcccc; /* Light Red */ }
        .row-attention { 
            background-color: #ffe4b2; /* Orange-Yellow for Attention */
            border: 2px solid #ffaa00;
        }
        
        /* Status and Tag Styles */
        .status-select { padding: 5px; border-radius: 4px; }

        /* Custom Tag Display */
        .status-tag { 
            padding: 5px 8px; 
            border-radius: 4px; 
            font-weight: bold; 
            display: inline-block;
            white-space: nowrap;
        }
        .status-tag.favorite { background-color: #f0ad4e; color: white; } /* Darker Yellow/Orange */
        .status-tag.worst { background-color: #d9534f; color: white; } /* Darker Red */


        /* Footer Style */
        footer { margin-top: 50px; font-size: 0.8em; color: #666; }
        
        #food-search-input {
            padding: 10px;
            font-size: 16px;
            width: 50%;
            margin-top: 10px;
        }
        #stomach-size-input {
            padding: 5px;
            width: 80px;
            text-align: right;
        }
        
        /* Centralization of Selects de Tags */
        #global-tags-section {
            display: flex;
            flex-direction: column;
            align-items: center; /* Centraliza o conteúdo (h3 e div) */
            margin-bottom: 20px;
        }
        #fav-worst-selects {
            display: flex;
            justify-content: space-between;
            width: 600px; /* Largura fixa para manter o alinhamento */
            max-width: 100%;
        }
        #fav-worst-selects select {
            padding: 8px;
            font-size: 14px;
            width: 280px;
        }

        /* Layout for Diet Section */
        #diet-suggestion-container {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 20px;
            margin-bottom: 40px;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 8px;
            background-color: #f9f9f9;
        }
        #suggested-foods-list {
            flex: 1;
            min-width: 50%;
        }
        #nutrition-pie-chart-container {
            width: 200px; /* Reduzido para o círculo */
            height: 200px;
            position: relative;
            border-radius: 50%;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        #pie-legend {
            margin-top: 20px;
        }
    </style>
</head>
<body>

    <div id="version-display">
        Version 0.1<br>
        Last update: <span id="last-update-date"></span>
    </div>
    
    <h1>Eco FoodCalc - Diet Optimizer</h1>
    
    <p>Current Session Status: <span id="user-session"></span></p> 
    <button onclick="resetPreferences()" style="padding: 5px 10px; background-color: #f44336; color: white; border: none; cursor: pointer; border-radius: 4px;">Reset All Preferences</button>
    
    <p>This tool helps maximize your **Nutrition Bonus** for faster skill point gain in Eco.</p>
    
    <div style="margin-bottom: 20px;">
        <label for="stomach-size-input">Stomach Size (Calories): </label>
        <input type="number" id="stomach-size-input" value="3000" min="100" onchange="updateStomachSize(this.value)">
    </div>
    
    <h2>Suggested Diet Optimization</h2>
    <div style="margin-bottom: 20px;">
        <label>
            <input type="checkbox" id="strict-taste-toggle" checked onchange="saveStrictTastePreference(this.checked)">
            Exclude Bad and Horrible foods from diet suggestion.
        </label>
    </div>
    <div id="diet-suggestion-container">
        <div id="suggested-foods-list">
            <p>Processing optimization algorithm...</p>
        </div>
        <div id="nutrition-pie-chart-container">
            </div>
    </div>
    <hr>
    
    <div id="food-container"></div> 

    <footer>
        <hr>
        <p>Created by CrazySpy.</p>
    </footer>

    <script>
        const FOOD_SOURCE_URL = 'foodsource.json';
        const STOMACH_SIZE_DEFAULT = 3000;
        
        // Define ALL possible status states.
        const FOOD_STATUS_KEYS = {
            'REMOVE_FROM_LIST': 'Remove from list', 
            'SELECT_STATUS': '--- SELECT STATUS ---', 
            'DELICIOUS': 'Delicious', 
            'GOOD': 'Good', 
            'OK': 'Ok', 
            'BAD': 'Bad', 
            'HORRIBLE': 'Horrible'
        };
        
        // Cores para o Gráfico de Pizza (Padrão: Carbs, Fat, Protein, Vitamins)
        const PIE_COLORS = {
            'Carbs': '#3498db',    // Azul
            'Fat': '#2ecc71',      // Verde
            'Protein': '#e74c3c',  // Vermelho
            'Vitamins': '#f1c40f'  // Amarelo
        };

        const STATUS_OPTIONS = Object.values(FOOD_STATUS_KEYS);
        const DATA_STORAGE_KEY = 'eco_food_preferences';
        const STOMACH_SIZE_KEY = 'eco_stomach_size';
        const FAVORITE_KEY = 'eco_favorite_food';
        const WORST_KEY = 'eco_worst_food';
        const STRICT_TASTE_KEY = 'eco_strict_taste'; // Novo para o toggle
        
        // Global variables
        let foodData = [];
        let userPreferences = {};
        let stomachSize = STOMACH_SIZE_DEFAULT;
        let favoriteFood = '';
        let worstFood = '';
        let strictTasteMode = true; // Novo: Padrão é TRUE
        
        const sessionElement = document.getElementById('user-session');
        const container = document.getElementById('food-container');


        // --- GLOBAL FUNCTIONS (Must be defined first for HTML onclicks) ---

        /**
         * Clears all saved data (preferences and stomach size) and reloads the app.
         */
        function resetPreferences() {
            if (confirm('Are you sure you want to delete ALL saved preferences (food status, tags, and stomach size)? This action cannot be undone.')) {
                localStorage.clear(); // Limpa tudo que for nosso
                
                // Recarrega o app para iniciar do zero
                window.location.reload();
            }
        }
        
        /**
         * Updates the stomach size variable and saves it.
         */
        function updateStomachSize(newValue) {
            stomachSize = parseInt(newValue) || STOMACH_SIZE_DEFAULT;
            saveStomachSize();
            console.log(`Stomach size updated to ${stomachSize} kcal.`);
            renderFoodLists(); 
        }

        /**
         * Saves the state of the strict taste toggle.
         */
        function saveStrictTastePreference(isChecked) {
            strictTasteMode = isChecked;
            localStorage.setItem(STRICT_TASTE_KEY, isChecked);
            renderFoodLists();
            console.log(`Strict taste mode set to: ${strictTasteMode}`);
        }

        /**
         * Sets a new Favorite or Worst food and re-renders the list.
         */
        function setGlobalTag(selectElement, tagType) {
            const foodName = selectElement.value;
            
            if (tagType === 'favorite') {
                favoriteFood = foodName;
                saveGlobalTag(FAVORITE_KEY, foodName);
            } else if (tagType === 'worst') {
                worstFood = foodName;
                saveGlobalTag(WORST_KEY, foodName);
            }

            // Limpa a tag se a opção "--- Select ---" ou "(None)" for escolhida
            if (!foodName) {
                if (tagType === 'favorite') favoriteFood = '';
                if (tagType === 'worst') worstFood = '';
                saveGlobalTag(tagType === 'favorite' ? FAVORITE_KEY : WORST_KEY, '');
            }

            renderFoodLists();
            console.log(`${tagType} food set to: ${foodName}`);
        }

        /**
         * Updates the status (Delicious, Good, etc.) for a food item and re-renders if needed.
         */
        function updateFoodStatus(foodName, newStatus) {
            const oldStatus = userPreferences[foodName].status;
            userPreferences[foodName].status = newStatus;
            
            // Apenas re-renderiza TUDO se o item entrar ou sair da lista principal (mudando de/para REMOVE_FROM_LIST)
            const isMovingList = (oldStatus === FOOD_STATUS_KEYS.REMOVE_FROM_LIST && newStatus !== FOOD_STATUS_KEYS.REMOVE_FROM_LIST) ||
                                 (oldStatus !== FOOD_STATUS_KEYS.REMOVE_FROM_LIST && newStatus === FOOD_STATUS_KEYS.REMOVE_FROM_LIST);

            saveUserPreferences();
            
            if (isMovingList) {
                 renderFoodLists(); 
            } else {
                // Se o item não saiu da lista, apenas recalcula a dieta e atualiza a tabela avaliada
                calculateSuggestedDiet();
                const evaluatedFoods = foodData.filter(item => userPreferences[item.Food_Name] && userPreferences[item.Food_Name].status !== FOOD_STATUS_KEYS.REMOVE_FROM_LIST);
                document.getElementById('food-container').querySelector('.food-list').outerHTML = renderEvaluatedTable(evaluatedFoods);
            }
        }
        
        /**
         * Adds a selected food from the search box to the evaluated list by updating its status.
         */
        function addFoodToEvaluatedList(foodName) {
            const itemKey = foodData.find(item => item.Food_Name === foodName)?.Food_Name;
            
            if (!itemKey || userPreferences[itemKey].status !== FOOD_STATUS_KEYS.REMOVE_FROM_LIST) {
                alert(`Food "${foodName}" not found or already evaluated.`);
                document.getElementById('food-search-input').value = ""; // Clear input
                return;
            }

            const defaultNewStatus = FOOD_STATUS_KEYS.SELECT_STATUS; 

            userPreferences[itemKey].status = defaultNewStatus;
            
            saveUserPreferences();
            renderFoodLists();
            
            document.getElementById('food-search-input').value = "";
        }

        // --- Core Helper Functions ---
        
        /**
         * Saves current user preferences to localStorage.
         */
        function saveUserPreferences() {
            localStorage.setItem(DATA_STORAGE_KEY, JSON.stringify(userPreferences));
        }

        /**
         * Saves the Stomach Size to localStorage.
         */
        function saveStomachSize() {
            localStorage.setItem(STOMACH_SIZE_KEY, stomachSize);
        }
        
        /**
         * Saves the global favorite/worst tag to localStorage.
         */
        function saveGlobalTag(tagKey, foodName) {
            localStorage.setItem(tagKey, foodName);
        }
        
        // --- Algorithmic Core (The Real Deal) ---

        /**
         * Placeholder: Calculates the Balance Modifier (0.5x to 2.0x).
         */
        function calculateBalanceModifier(analysis) {
             const nutrients = [analysis.Carbs, analysis.Fat, analysis.Protein, analysis.Vitamins];
             const avg = 25;
             const variance = nutrients.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / 4;
             const stdDev = Math.sqrt(variance);
             
             let modifier = 2.0 - (stdDev / 10);
             if (modifier < 0.5) modifier = 0.5;
             
             return `${modifier.toFixed(2)}x`;
        }
        
        /**
         * Renders the nutrient distribution legend/analysis.
         */
        function renderPieChart(analysis) {
            const chartContainer = document.getElementById('nutrition-pie-chart-container');
            const data = [
                { label: 'Carbs', percent: analysis.Carbs, color: PIE_COLORS.Carbs },
                { label: 'Fat', percent: analysis.Fat, color: PIE_COLORS.Fat },
                { label: 'Protein', percent: analysis.Protein, color: PIE_COLORS.Protein },
                { label: 'Vitamins', percent: analysis.Vitamins, color: PIE_COLORS.Vitamins }
            ].sort((a, b) => b.percent - a.percent); // Ordena decrescente para renderização do gradiente

            let currentPercentage = 0;
            const gradientParts = [];
            
            data.forEach(slice => {
                // Adiciona a cor e o ponto onde a cor começa
                gradientParts.push(`${slice.color} ${currentPercentage.toFixed(2)}%`);
                // Adiciona a cor e o ponto onde a cor termina (próxima cor começa aqui)
                currentPercentage += slice.percent;
                gradientParts.push(`${slice.color} ${currentPercentage.toFixed(2)}%`);
            });

            // Remove o último ponto de repetição
            gradientParts.pop(); 
            
            const gradientString = gradientParts.join(', ');

            chartContainer.style.background = `conic-gradient(${gradientString})`;
            
            const balanceModifier = calculateBalanceModifier(analysis);

            // Renderiza o rótulo central e a legenda
            document.getElementById('suggested-foods-list').querySelector('h4').textContent = `Optimal Meal: ${balanceModifier}`;

            // Renderiza legenda separada
            const legendHtml = `
                <div id="pie-legend">
                    <p style="text-align: center;"><strong>Balance Modifier: ${balanceModifier}</strong></p>
                    <ul style="list-style-type: none; padding: 0; margin: 0; font-size: 0.9em;">
                        ${data.map(slice => 
                            `<li style="margin-bottom: 5px;">
                                <span style="display: inline-block; width: 10px; height: 10px; background-color: ${slice.color}; margin-right: 4px; border-radius: 2px;"></span> 
                                ${slice.label}: ${slice.percent.toFixed(1)}% 
                            </li>`
                        ).join('')}
                    </ul>
                </div>
            `;
            // Substitui a lista de comidas pelo resultado da otimização e a legenda
            document.getElementById('suggested-foods-list').innerHTML += legendHtml;
        }

        /**
         * Finds the optimal diet (Knapsack Problem approach).
         */
        function findOptimalDiet(availableFoods) {
            const TARGET_PERCENTAGE = 0.25; // Goal: 25% for each nutrient
            
            // Step 1: Pre-process available foods (calculate nutrient ratios per calorie)
            const processedFoods = availableFoods.map(food => ({
                name: food.Food_Name,
                calories: food.Official_Calories_Game,
                carbs: food.Carbs,
                fat: food.Fat,
                protein: food.Protein,
                vitamins: food.Vitamins,
                // Optional: priority score for Delicious/Favorite foods
                priority: (food.Food_Name === favoriteFood) ? 2 : (userPreferences[food.Food_Name].status === FOOD_STATUS_KEYS.DELICIOUS ? 1 : 0),
            }));

            // Storage for current diet and totals
            let currentCalories = 0;
            let currentNutrients = { Carbs: 0, Fat: 0, Protein: 0, Vitamins: 0 };
            let suggestedDiet = []; // { food: food object, count: N }

            // --- Greedy Algorithm Start ---
            
            // Loop while there is space in the stomach
            while (currentCalories < stomachSize) {
                
                // Calculate the current deficiency (variance from 25%)
                const totalNutrients = currentNutrients.Carbs + currentNutrients.Fat + currentNutrients.Protein + currentNutrients.Vitamins;
                const currentDistribution = totalNutrients > 0 ? {
                    Carbs: currentNutrients.Carbs / totalNutrients,
                    Fat: currentNutrients.Fat / totalNutrients,
                    Protein: currentNutrients.Protein / totalNutrients,
                    Vitamins: currentNutrients.Vitamins / totalNutrients,
                } : { Carbs: 0, Fat: 0, Protein: 0, Vitamins: 0 };
                
                // Find the MOST deficient nutrient
                let mostDeficientNutrient = null;
                let maxDeficiency = -Infinity;
                
                for (const nutrient in currentDistribution) {
                    const deficiency = TARGET_PERCENTAGE - currentDistribution[nutrient];
                    if (deficiency > maxDeficiency) {
                        maxDeficiency = deficiency;
                        mostDeficientNutrient = nutrient;
                    }
                }
                
                // Find the best food to fill that deficiency
                let bestFoodToEat = null;
                let bestFoodScore = -Infinity;

                for (const food of processedFoods) {
                    if (currentCalories + food.calories > stomachSize) continue;

                    // Score: How effectively does this food fill the deficiency?
                    // Simplified Score: (Nutrient_Value / Total_Nutrients_in_Food) * Priority
                    const foodTotalNutrients = food.carbs + food.fat + food.protein + food.vitamins;
                    if (foodTotalNutrients === 0) continue; 
                    
                    const nutrientValueInFood = food[mostDeficientNutrient.toLowerCase()]; // e.g., food.carbs
                    const deficiencyFillRatio = nutrientValueInFood / foodTotalNutrients;
                    
                    // Incorporate Priority (Gosto): foods the player likes get a multiplier
                    let score = deficiencyFillRatio * (1 + food.priority); 
                    
                    if (score > bestFoodScore) {
                        bestFoodScore = score;
                        bestFoodToEat = food;
                    }
                }

                if (!bestFoodToEat) {
                    // Cannot fit any more food, or no foods are available to improve the balance
                    break;
                }

                // Consume the best food found
                currentCalories += bestFoodToEat.calories;
                currentNutrients.Carbs += bestFoodToEat.carbs;
                currentNutrients.Fat += bestFoodToEat.fat;
                currentNutrients.Protein += bestFoodToEat.protein;
                currentNutrients.Vitamins += bestFoodToEat.vitamins;
                
                // Add to suggested diet list (combine duplicates)
                const existingEntry = suggestedDiet.find(e => e.name === bestFoodToEat.name);
                if (existingEntry) {
                    existingEntry.count++;
                } else {
                    suggestedDiet.push({ name: bestFoodToEat.name, count: 1, calories: bestFoodToEat.calories });
                }
            }

            // --- Final Analysis ---
            
            const totalNutrients = currentNutrients.Carbs + currentNutrients.Fat + currentNutrients.Protein + currentNutrients.Vitamins;

            const dietAnalysis = {
                Carbs: (currentNutrients.Carbs / totalNutrients) * 100,
                Fat: (currentNutrients.Fat / totalNutrients) * 100,
                Protein: (currentNutrients.Protein / totalNutrients) * 100,
                Vitamins: (currentNutrients.Vitamins / totalNutrients) * 100,
                TotalCalories: currentCalories
            };
            
            // --- Renderizar Resultados Finais ---
            
            listContainer.innerHTML = '<h4>Suggested Meal Plan:</h4>';
            listContainer.innerHTML += `
                <p><strong>Goal Calories: ${stomachSize} Kcal</strong></p>
                <p><strong>Total Diet Calories: ${dietAnalysis.TotalCalories} Kcal (Remaining: ${stomachSize - dietAnalysis.TotalCalories} Kcal)</strong></p>
                <ul style="list-style-type: none; padding: 0;">
                    ${suggestedDiet.map(entry => `<li>- ${entry.count}x ${entry.name} (${entry.calories} Kcal each)</li>`).join('')}
                </ul>
            `;
            
            renderPieChart(dietAnalysis);
        }

        // --- Core Functions (Non-Global) ---

        /**
         * Initializes the application.
         */
        async function initApp() {
            
            sessionElement.textContent = 'Checking preferences...';
            container.innerHTML = 'Loading food data...'; // Dynamic loading message

            try {
                // 1. Load the JSON file
                const response = await fetch(FOOD_SOURCE_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                foodData = await response.json();

                // 2. Load user preferences, stomach size, and global tags
                loadUserPreferences();
                loadStomachSize();
                loadGlobalTags();
                loadStrictTastePreference(); // Carrega o estado do toggle

                // 3. Render the two main components (Evaluated List + Search)
                renderFoodLists(); 
                
            } catch (error) {
                console.error("Error loading or processing JSON:", error);
                container.innerHTML = `<p style="color: red;">Error loading ${FOOD_SOURCE_URL}. Please check the file name and format.</p>`;
                sessionElement.textContent = 'Failed to start session.';
            }

            // 4. Fetch the last commit date (footer/header)
            fetchLastCommitDate();
        }

        /**
         * Renders the two main lists: Evaluated Foods Table and Search Box.
         */
        function renderFoodLists() {
            // Separa as comidas em avaliadas e não avaliadas
            const allFoods = [...foodData];
            const evaluatedFoods = allFoods.filter(item => {
                const prefs = userPreferences[item.Food_Name];
                return prefs && prefs.status !== FOOD_STATUS_KEYS.REMOVE_FROM_LIST;
            });
            const unevaluatedFoods = allFoods.filter(item => {
                const prefs = userPreferences[item.Food_Name];
                return !prefs || prefs.status === FOOD_STATUS_KEYS.REMOVE_FROM_LIST;
            });
            
            // NOVO: CHAMA O ALGORITMO AQUI!
            calculateSuggestedDiet(); 
            
            // Renderiza os seletores de Favorite/Worst globais
            let html = renderGlobalTagSelectors(evaluatedFoods);

            // Tabela de avaliadas
            html += '<h2>1. Your Evaluated Foods</h2>';
            html += `<p>Manage the foods you have already tried. (Evaluated Foods: ${evaluatedFoods.length})</p>`;
            html += renderEvaluatedTable(evaluatedFoods);

            html += '<hr style="margin: 40px 0;">';
            
            // Interface de busca
            html += '<h2>2. Evaluate New Foods</h2>';
            html += '<p>Search or select a food to add it to your evaluated list and set its status.</p>';
            html += renderSearchInterface(unevaluatedFoods);

            container.innerHTML = html;
            
            // Garante que o toggle está com o estado correto
            document.getElementById('strict-taste-toggle').checked = strictTasteMode;
        }

        /**
         * Renders the new global Favorite/Worst selectors.
         */
        function renderGlobalTagSelectors(foods) {
            
            const generateSelectHtml = (tagType) => {
                const currentValue = tagType === 'favorite' ? favoriteFood : worstFood;
                
                const options = foods.map(item => {
                    const name = item.Food_Name;
                    const isSelected = name === currentValue;
                    return `<option value="${name}" ${isSelected ? 'selected' : ''}>${name}</option>`;
                }).join('');

                return `
                    <select onchange="setGlobalTag(this, '${tagType}')">
                        <option value="" ${currentValue === '' ? 'selected' : ''}>--- Select ---</option>
                        ${options}
                        <option value="" disabled>---</option>
                        <option value="">(None)</option>
                    </select>
                `;
            };


            return `
                <div id="global-tags-section">
                    <h3>Global Taste Tags (Single Selection)</h3>
                    <div id="fav-worst-selects">
                        <label>Favorite Food (1): ${generateSelectHtml('favorite')}</label>
                        <label>Worst Food (1): ${generateSelectHtml('worst')}</label>
                    </div>
                </div>
            `;
        }

        /**
         * Renders the table for foods that have an explicit status set.
         */
        function renderEvaluatedTable(foods) {
            if (foods.length === 0) {
                return '<p>No foods evaluated yet. Use the search field below to add your first item!</p>';
            }

            let tableHtml = '<table class="food-list">';
            tableHtml += '<thead><tr><th>Food Name</th><th>Carbs</th><th>Fat</th><th>Protein</th><th>Vitamins</th><th>Calories (Game)</th><th>Status</th></tr></thead>';
            tableHtml += '<tbody>';

            foods.forEach(item => {
                const name = item.Food_Name;
                const prefs = userPreferences[name];
                
                const isFavorite = name === favoriteFood;
                const isWorst = name === worstFood;
                const needsAttention = prefs.status === FOOD_STATUS_KEYS.SELECT_STATUS;
                
                let rowClass = '';
                let statusCellContent;

                if (isFavorite) {
                    rowClass = 'row-favorite';
                    statusCellContent = `<span class="status-tag favorite">★ FAVORITE</span>`;
                } else if (isWorst) {
                    rowClass = 'row-worst';
                    statusCellContent = `<span class="status-tag worst">☠ WORST</span>`;
                } else {
                    if (needsAttention) {
                         rowClass = 'row-attention';
                    }
                    statusCellContent = `
                        <select class="status-select" onchange="updateFoodStatus('${name}', this.value)">
                            ${STATUS_OPTIONS.map(s => 
                                `<option value="${s}" ${s === prefs.status ? 'selected' : ''}>${s}</option>`
                            ).join('')}
                        </select>
                    `;
                }
                
                tableHtml += `<tr class="${rowClass}">
                    <td>${name}</td>
                    <td>${item.Carbs}</td>
                    <td>${item.Fat}</td>
                    <td>${item.Protein}</td>
                    <td>${item.Vitamins}</td>
                    <td>${item.Official_Calories_Game}</td>
                    <td>${statusCellContent}</td>
                </tr>`;
            });

            tableHtml += '</tbody></table>';
            return tableHtml;
        }

        /**
         * Renders the search/selection interface (using datalist for type-ahead search).
         */
        function renderSearchInterface(foods) {
            const options = foods.map(item => `<option value="${item.Food_Name}">`).join('');
            
            let searchHtml = `
                <input list="food-datalist" id="food-search-input" onchange="addFoodToEvaluatedList(this.value)" placeholder="Type or select food name (${foods.length} remaining)" autocomplete="off">
                <datalist id="food-datalist">
                    ${options}
                </datalist>
                <p style="margin-top: 10px; font-size: 0.9em; color: #666;">Note: After typing a name, click outside the box or press Enter to add the food.</p>
            `;
            return searchHtml;
        }
        
        /**
         * Loads the state of the strict taste toggle.
         */
        function loadStrictTastePreference() {
            const storedStrict = localStorage.getItem(STRICT_TASTE_KEY);
            if (storedStrict !== null) {
                strictTasteMode = storedStrict === 'true';
            }
        }


        // Initialize the application
        initApp();
    </script>
</body>
</html>
